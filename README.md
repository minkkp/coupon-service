# 선착순 쿠폰 발급 시스템

> Redis와 Lua를 활용해  
> 대규모 동시 요청 환경에서도  
> 한정 수량의 쿠폰을 정확하게 발급하고,
> 장애 대응까지 고려한 토이 프로젝트입니다.

---

## 📌 프로젝트 목적

- 대규모 트래픽 환경에서 한정 수량 쿠폰을 정확하게 발급
- 트래픽 증가, Redis 장애, 운영 복구까지 고려한 설계 경험
- 쿠폰 과발급 / 중복 발급 방지
---

## 🧠 핵심 설계 요약

- Redis + Lua 기반 선착순 제어 (원자 처리)  
  → 단일 Redis 연산으로 동시성 환경에서도 race condition 방지
- 쿠폰 발급 처리와 이력 저장을 분리하여 병목 제거
- Redis 장애 시 Fail-Fast 전략 적용  
  → 대체 처리 없이 즉시 실패 처리하여 정합성 유지  
  → DB의 쿠폰수량 기준으로 Redis 쿠폰 수량 상태를 재설정하는 동기화 API 제공
- 이벤트 종료 시 Redis 키를 즉시 삭제하고, 혹시 모를 누락을 대비해 만료 시간(TTL)도 함께 설정

---

## 🏗️ 아키텍처 개요

- **Redis**
  - 쿠폰 재고 및 요청 사용자 관리
  - Lua 스크립트로 쿠폰 요청 체크 + 재고 감소를 단일 연산으로 처리
    
- **DB**
  - 발급 성공 이력만 비동기로 저장

- **Application**
  - 쿠폰 발급 흐름 오케스트레이션
  - 이벤트 생명주기(open / close / sync) 관리

---

## 🧩 핵심 코드 구성

- CouponFacadeService  
  → 쿠폰 발급 전체 흐름 오케스트레이션

- RedisCouponService  
  → Redis + Lua 기반 쿠폰 발급 제어

- EventService  
  → 이벤트 생명주기 및 운영(open / close / sync) 관리

- AsyncCouponIssueService  
  → 발급 이력을 비동기 DB 저장

---

## 🔄 쿠폰 발급 흐름

1. 이벤트 상태 및 기간 검증 (DB)
2. Redis + Lua를 통한 선착순 발급 처리
   - 중복 참여 체크
   - 한정 수량 재고 확인 및 감소
3. 발급 성공 시에만 DB에 비동기 이력 저장
4. 즉시 응답 반환

---

## 🚨 장애 · 이슈 대응 전략

### Redis 장애
- Redis 오류 발생 시 즉시 실패 응답 (Fail-Fast)
- 불완전한 발급을 방지하기 위해 fallback 없이 처리

### DB 비동기 저장 실패
- 발급 결과에는 영향 없음
- 운영자가 syncEvent API 호출
  - DB를 기준(Source of Truth)으로 Redis 재고 복구

### 이벤트 종료 처리
- 이벤트 종료 시 Redis 키 즉시 제거
- TTL을 사용하여 이벤트 종료 시간 기준으로 Redis 키를 제거하여 2차 안전장치 제공

---

## 🗂️ ERD

> 쿠폰 발급 도메인 구조 및 관계  
> (ERD 이미지 첨부)

---

## ⚡ 부하 테스트 (k6)

### 테스트 조건
- 시나리오: 한정 수량 선착순 쿠폰 발급
- 요청 방식: constant-arrival-rate
- 초당 요청 수: 약 2,800
- 테스트 시간: 60초
- 최대 VU: 3,000
- 한정 수량 쿠폰: 100,000

### 테스트 결과
- 총 요청 수: 113,286
- 쿠폰 발급 성공: **100,000**
- SOLD_OUT: 13,286
- HTTP 실패: **0%**
- 과발급: **0건**
- 평균 응답 시간: 약 **1.5초**
- P95 응답 시간: 약 **1.7초**

**요약:**  
10만 건 발급을 목표로 한 선착순 이벤트에서  
정확한 수량 보장과 안정적인 응답을 확인

(콘솔 결과 이미지 첨부)

---

## ✍️ 마무리

이 프로젝트를 통해  
동시성 제어를 단순 구현이 아닌,  
기술 선택(Redis/Lua)과 운영 관점까지 고려해 설계하는 경험을 할 수 있었습니다.

실무 환경에서의 확장 가능성(Kafka, 알림, 통계 처리 등)은  
현재 구조를 기반으로 자연스럽게 확장할 수 있도록 설계했습니다.
