# 선착순 쿠폰 발급 시스템

> Redis와 Lua를 활용해  
> **대규모 동시 요청 환경에서도 정확한 수량의 선착순 쿠폰 발급**과  
> **장애·운영 대응까지 고려한 시스템**을 구현한 토이 프로젝트입니다.

---

## 📌 프로젝트 목적

- 대규모 트래픽 환경에서 **선착순 쿠폰을 정확한 수량만큼 발급**
- 과발급 / 중복 발급 방지
- 트래픽 증가, Redis 장애, 운영 복구까지 고려한 설계 경험

---

## 🧠 핵심 설계 요약

- **Redis + Lua**로 선착순 제어 (원자 처리)
- **DB 비동기 저장**으로 발급 API 응답 경로에서 DB 제거
- Redis 장애 시 **Fail-Fast 전략** 적용
- DB를 기준으로 Redis 상태를 복구하는 **운영 Sync API 제공**
- Redis TTL + closeEvent를 통한 **이중 안전장치**

---

## 🏗️ 아키텍처 개요

- **Redis**
  - 재고(stock) 및 참여 유저(users) 관리
  - Lua 스크립트로 중복 체크 + 재고 감소 원자 처리

- **DB**
  - 발급 성공 이력만 저장
  - 실시간 제어 ❌ / 최종 이력 저장 ⭕️

- **Application**
  - 발급 흐름 오케스트레이션
  - 이벤트 생명주기(open / close / sync) 관리

---

## 🧩 핵심 코드 구성

- **CouponFacadeService**  
  → 쿠폰 발급 전체 흐름 오케스트레이션

- **RedisCouponService**  
  → Redis + Lua 기반 선착순 발급 제어

- **EventService**  
  → 이벤트 생명주기 및 운영(open / close / sync) 관리

- **AsyncCouponIssueService**  
  → 발급 성공 이력 비동기 DB 저장

---

## 🔄 쿠폰 발급 흐름

1. 이벤트 상태 및 기간 검증 (DB)
2. Redis + Lua로 선착순 발급 처리
   - 중복 참여 체크
   - 재고 확인 및 감소
3. 발급 성공 시에만 DB에 비동기 이력 저장
4. 즉시 응답 반환

---

## 🚨 장애 · 이슈 대응 전략

### Redis 장애
- Redis 오류 발생 시 즉시 실패 응답 (Fail-Fast)
- DB fallback ❌ → 정합성 훼손 방지

### DB 비동기 저장 실패
- 발급 결과에는 영향 없음
- 운영자가 `syncEvent` API 호출
  - DB를 기준(Source of Truth)으로 Redis 재고 복구

### 이벤트 종료 처리
- `closeEvent` 시 Redis 키 즉시 제거
- TTL 설정으로 close 누락 시 2차 안전장치 제공

---

## 🗂️ ERD

> 쿠폰 발급 도메인 구조 및 관계  
> (이미지 첨부)

---

## ⚡ 부하 테스트 (k6)

### 테스트 조건
- 시나리오: 선착순 쿠폰 발급
- 요청 방식: constant-arrival-rate
- 초당 요청 수: 약 2,800
- 테스트 시간: 60초
- 최대 VU: 3,000
- 쿠폰 수량: 100,000

### 테스트 결과
- 총 요청 수: **113,286**
- 쿠폰 발급 성공: **100,000**
- SOLD_OUT: **13,286**
- HTTP 실패: **0%**
- 과발급: **0건**

> Redis + Lua 기반 선착순 제어가  
> 대규모 동시 요청 환경에서도  
> 정확성과 안정성을 만족함을 검증

(콘솔 결과 이미지 첨부)

---

## ✍️ 마무리

이 프로젝트는 단순 기능 구현이 아닌,  
**동시성 문제 해결, 성능 최적화, 장애·운영 대응까지 고려한 설계 경험**을 목표로 했습니다.

실무 환경에서의 확장 가능성(Kafka, 알림, 통계 처리 등)은  
현재 구조를 기반으로 자연스럽게 확장할 수 있도록 설계했습니다.
**
